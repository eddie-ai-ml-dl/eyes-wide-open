We are continuing development of a **People Counting and Direction Detection** system. Start from the state described below and implement the next work item: **Refine “INSIDE” Region Definition**.

### 1) Goal of the application (short)

Detect, track, and count people entering/exiting an area by analyzing tracked trajectories relative to a user-defined curve drawn across an entrance. The system must work across camera placements (front/back/side/overhead), auto-detect orientation when necessary, persist configs and diagnostics, and provide reliable IN/OUT counts.

### 2) Current project state (assume this exact state)

Files & responsibilities:

* `main.py` — live/recorded video loop, loads curve config, collects sample anchors, calls `CurveManager` to determine orientation, does detection/tracking and counting via `modules/tracker_logic`.
* `modules/curve_manager.py` — interactive curve creation (left-click to add, right-click/u to undo, `s` or double-click to save, ESC cancel), load/save config, `determine_orientation(sample_anchors)` which calls `modules.orientation.auto_orient_curve`, persists `orientation` and diagnostics to `curve_config.json`. Current `create_curve()` saves `"IN_direction": "auto"`, `determine_orientation()` resolves orientation and saves `IN_direction` to one of `"toward_cam"`/`"away_from_cam"`/`"left"`/`"right"`.
* `modules/orientation.py` — contains `auto_orient_curve(curve_np, sample_points, eps=..., min_crossings=...)` that returns `(orientation:int, diagnostics:dict)`. Diagnostics must be persisted with floats rounded to **2 decimals**.
* `modules/tracker_logic.py` — contains `signed_distance_to_curve(pt, curve)` and `update_track_state(...)`.
* `utils/viz_tools.py` — plotting helper `plot_trajectory(path, curve=None)`.
* `config/curve_config.json` — saved by CurveManager with schema (example):

```json
{
  "curve_points": [[722,390],[721,421],[674,438],[555,418],[459,387],[461,366]],
  "IN_direction": "toward_cam",
  "orientation": 1,
  "camera_orientation": "front-facing",
  "orientation_diagnostics": { "num_samples": 16, "confidence": 0.76, ... }
}
```

What currently works:

* Interactive curve creation & save.
* Auto-orientation from collected sample anchors; orientation & diagnostics saved.
* Detection/tracking and counting pipeline integrated.
* Test harness exists to label trajectory points offline.

Known issues to respect:

* `build_inside_region()` previously threw `ValueError` when passed `"auto"`. We resolved the flow so that `IN_direction` must be concrete before building inside region.
* We require diagnostics rounding to two decimals on save.

### 3) Next item to implement (detailed): **Refine INSIDE Region Definition**

We must replace the brittle, axis-aligned `build_inside_region()` logic with a **geometry-driven method** that works for any curve orientation and camera placement. Implement this inside `modules/curve_manager.py` (or a new helper `modules/geometry_utils.py` if you prefer).

#### Requirements (functional)

1. **Normal-vector based INSIDE region**

   * Compute the tangent for each segment of the curve (p[i] → p[i+1]).
   * Compute a perpendicular (normal) for each tangent. Normalize normals.
   * Compute a *smoothed* normal for the whole curve (e.g., average segment normals, or per-vertex averaging) to get a consistent direction for the side offsets.
   * Use `orientation` (±1) to choose which side is IN:

     * If orientation == `1` and camera convention is `front-facing` (or `IN_direction == "toward_cam"`), then IN is the screen side determined by the orientation algorithm (you may use the sign logic from `auto_orient_curve` to choose).
     * If orientation == `-1`, flip the offset direction.

2. **Offset the curve to create an INSIDE polygon**

   * Parameter `region_depth` (default 50 px, configurable in config). For each point p_i, create an offset point p_i' = p_i + (normal_i * region_depth * orientation).
   * Construct a closed polygon by concatenating the original curve points and the reversed offset points:

     ```
     inside_polygon = [p0, p1, ..., pN] + [pN', pN-1', ..., p0']
     ```
   * Ensure polygon has correct winding and is valid for `cv2.pointPolygonTest`.

3. **Save the INSIDE polygon to config**

   * Add key `"inside_region": [[x,y], ...]` to `curve_config.json`.
   * Also save `"region_depth"` and `"region_method": "normal_offset"`.
   * Round all numeric diagnostics and coordinates saved in config to **2 decimals** (but coordinates can be floats).

4. **Fallback behavior**

   * If `IN_direction` is `"auto"` and orientation not yet resolved:

     * Create a *symmetric* neutral polygon (offset both sides equally) so code can run without error.
     * Once orientation is resolved, recompute and persist a proper inside region.

5. **Visualization**

   * When plotting or drawing on frames, show:

     * Counting curve (yellow polyline).
     * Inside polygon overlay (semi-transparent green fill or green outline).
     * Optional small arrows along the curve indicating IN direction (based on computed normal).
   * Provide a function `CurveManager.visualize_region(frame, color_inside=(0,200,0), alpha=0.2)` that overlays on an image.

6. **API / function signatures**

   * `CurveManager.build_inside_region(curve_points_np: np.ndarray, orientation: int, region_depth: float = 50.0) -> np.ndarray`
     (returns polygon Nx2 float32)
   * `CurveManager.save_inside_region()` — writes `inside_region` and region metadata into `curve_data` and persists.
   * Keep backwards compatibility: if `inside_region` exists in config, `load_curve_config()` should load it and not recompute unless forced.

7. **Robustness & edge cases**

   * Handle short curves (2 points) gracefully.
   * Avoid self-intersecting polygons — if geometry suggests a crossing, reduce `region_depth` adaptively or warn in diagnostics.
   * Provide diagnostics: `{"method":"normal_offset","region_depth":50.0,"status":"ok","notes":[], "num_points": N}`.

#### Tests & acceptance criteria

* Unit tests (or simple scripts) to run:

  1. Load the sample curve:

     ```
     curve = [(722,390),(721,421),(674,438),(555,418),(459,387),(461,366)]
     ```

     Compute inside polygon with `orientation=1` and `region_depth=50`. Visual inspection: inside polygon should be on consistent side and not cross the curve.
  2. Use the existing test trajectories (that previously had no crossings) to verify:

     * Points that visually lie on one side of the curve are labeled consistently (no false IN flips).
     * Trajectories that cross the curve flip label when they cross the new `inside_region` boundary (use `signed_distance_to_curve` *and* `pointPolygonTest` against `inside_region` if needed).
  3. Fallback test: create curve with `"IN_direction": "auto"` and simulate initial run before orientation resolved — verify neutral symmetric polygon used and no crash occurs.
  4. Persistence test: after computing inside region, `curve_config.json` should include `inside_region`, `region_depth`, `region_method`, and rounded diagnostics (2 decimals).

* Visual test: run the video with interactive curve creation. After saving curve, verify that:

  * The inside polygon overlays correctly.
  * Orientation auto-detect resolves and `curve_config.json` updates with a resolved `IN_direction` and `inside_region`.

#### Diagnostics & persistence detail

* All numbers in `orientation_diagnostics` and `inside_region` saved to JSON must be rounded to **2 decimal places** (use `round(x,2)` recursively).
* Save a `region_diagnostics` object with fields: `{ "method": "normal_offset", "region_depth": <float>, "num_points": <int>, "status": "ok" or "adjusted", "notes": [] }`.

#### Integration & minimal main.py changes

* `main.py` should:

  * Load curve via `cm.load_curve_config()`.
  * If `inside_region` present and `IN_direction` is concrete → use it.
  * If `inside_region` missing and `IN_direction` concrete → call `cm.build_inside_region(...)` once and `cm.save_inside_region()`.
  * If `IN_direction` is `"auto"` and orientation not resolved → call `cm.build_inside_region_symmetric(curve)` (neutral fallback) so loop does not crash; after auto-orientation, recompute and persist resolved inside region.
* Provide a logging print that indicates when inside region was computed or loaded.

### 4) Implementation constraints / style

* Keep consistent naming conventions (`inside_region` lower-case variable).
* Keep API calls minimal and backward compatible with other modules.
* Avoid changing `signed_distance_to_curve` behavior for now; use the polygon for `point-in-region` checks where appropriate.
* Keep `CurveManager` as the authoritative place that computes and persists region geometry.

### 5) Deliverables I expect from you in the new conversation

1. Updated implementation of `build_inside_region()` (or new helper) matching the spec above.
2. Modified `CurveManager` methods to (a) compute, (b) persist `inside_region`, (c) provide `visualize_region()` overlay.
3. Minimal `main.py` patch showing where to call build/load/persist and how to use the neutral fallback for `"auto"`.
4. One or two concise unit/test scripts I can run locally (no external web) that:

   * compute inside polygon for the sample curve and display/save an overlay image;
   * run a sample trajectory through labeling and show expected label changes (textual output).
5. Ensure all saved diagnostics and coordinates in JSON are rounded to 2 decimals.

---

If anything in this prompt is ambiguous or you need the exact file contents from the current repo to continue, ask for the specific file(s) (e.g., paste `modules/curve_manager.py` and `main.py`) and I’ll use them. Otherwise start by implementing geometry-based `build_inside_region()` and the persistence behavior described above.
